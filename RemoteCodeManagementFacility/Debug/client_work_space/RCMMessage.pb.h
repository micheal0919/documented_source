// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RCMMessage.proto

#ifndef PROTOBUF_RCMMessage_2eproto__INCLUDED
#define PROTOBUF_RCMMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RCMMessage {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_RCMMessage_2eproto();
void protobuf_AssignDesc_RCMMessage_2eproto();
void protobuf_ShutdownFile_RCMMessage_2eproto();

class UploadRequest;
class UploadResponse;
class DownloadRequest;
class DownladResponse;
class ListRequest;
class LisrResponse;
class SearchRequest;
class SearchResponse;
class Request;
class Response;
class Message;

enum MSG {
  Upload_Request = 4097,
  Upload_Response = 4098,
  Download_Request = 4099,
  Download_Response = 4100,
  List_Request = 4101,
  List_Response = 4102,
  Find_Request = 4103,
  Find_Response = 4104,
  Search_Request = 4105,
  Search_Response = 4112
};
bool MSG_IsValid(int value);
const MSG MSG_MIN = Upload_Request;
const MSG MSG_MAX = Search_Response;
const int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::google::protobuf::EnumDescriptor* MSG_descriptor();
inline const ::std::string& MSG_Name(MSG value) {
  return ::google::protobuf::internal::NameOfEnum(
    MSG_descriptor(), value);
}
inline bool MSG_Parse(
    const ::std::string& name, MSG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
// ===================================================================

class UploadRequest : public ::google::protobuf::Message {
 public:
  UploadRequest();
  virtual ~UploadRequest();

  UploadRequest(const UploadRequest& from);

  inline UploadRequest& operator=(const UploadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadRequest& default_instance();

  void Swap(UploadRequest* other);

  // implements Message ----------------------------------------------

  inline UploadRequest* New() const { return New(NULL); }

  UploadRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadRequest& from);
  void MergeFrom(const UploadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // required string IP = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required bool fileSet = 3;
  bool has_fileset() const;
  void clear_fileset();
  static const int kFileSetFieldNumber = 3;
  bool fileset() const;
  void set_fileset(bool value);

  // required bool fileEnd = 4;
  bool has_fileend() const;
  void clear_fileend();
  static const int kFileEndFieldNumber = 4;
  bool fileend() const;
  void set_fileend(bool value);

  // required bytes content = 5;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 5;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:RCMMessage.UploadRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_fileset();
  inline void clear_has_fileset();
  inline void set_has_fileend();
  inline void clear_has_fileend();
  inline void set_has_content();
  inline void clear_has_content();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  bool fileset_;
  bool fileend_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static UploadRequest* default_instance_;
};
// -------------------------------------------------------------------

class UploadResponse : public ::google::protobuf::Message {
 public:
  UploadResponse();
  virtual ~UploadResponse();

  UploadResponse(const UploadResponse& from);

  inline UploadResponse& operator=(const UploadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadResponse& default_instance();

  void Swap(UploadResponse* other);

  // implements Message ----------------------------------------------

  inline UploadResponse* New() const { return New(NULL); }

  UploadResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadResponse& from);
  void MergeFrom(const UploadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:RCMMessage.UploadResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static UploadResponse* default_instance_;
};
// -------------------------------------------------------------------

class DownloadRequest : public ::google::protobuf::Message {
 public:
  DownloadRequest();
  virtual ~DownloadRequest();

  DownloadRequest(const DownloadRequest& from);

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadRequest& default_instance();

  void Swap(DownloadRequest* other);

  // implements Message ----------------------------------------------

  inline DownloadRequest* New() const { return New(NULL); }

  DownloadRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadRequest& from);
  void MergeFrom(const DownloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:RCMMessage.DownloadRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static DownloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class DownladResponse : public ::google::protobuf::Message {
 public:
  DownladResponse();
  virtual ~DownladResponse();

  DownladResponse(const DownladResponse& from);

  inline DownladResponse& operator=(const DownladResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownladResponse& default_instance();

  void Swap(DownladResponse* other);

  // implements Message ----------------------------------------------

  inline DownladResponse* New() const { return New(NULL); }

  DownladResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownladResponse& from);
  void MergeFrom(const DownladResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownladResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 isError = 1;
  bool has_iserror() const;
  void clear_iserror();
  static const int kIsErrorFieldNumber = 1;
  ::google::protobuf::int32 iserror() const;
  void set_iserror(::google::protobuf::int32 value);

  // optional string errorInfo = 2;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  const ::std::string& errorinfo() const;
  void set_errorinfo(const ::std::string& value);
  void set_errorinfo(const char* value);
  void set_errorinfo(const char* value, size_t size);
  ::std::string* mutable_errorinfo();
  ::std::string* release_errorinfo();
  void set_allocated_errorinfo(::std::string* errorinfo);

  // @@protoc_insertion_point(class_scope:RCMMessage.DownladResponse)
 private:
  inline void set_has_iserror();
  inline void clear_has_iserror();
  inline void set_has_errorinfo();
  inline void clear_has_errorinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errorinfo_;
  ::google::protobuf::int32 iserror_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static DownladResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListRequest : public ::google::protobuf::Message {
 public:
  ListRequest();
  virtual ~ListRequest();

  ListRequest(const ListRequest& from);

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRequest& default_instance();

  void Swap(ListRequest* other);

  // implements Message ----------------------------------------------

  inline ListRequest* New() const { return New(NULL); }

  ListRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRequest& from);
  void MergeFrom(const ListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:RCMMessage.ListRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static ListRequest* default_instance_;
};
// -------------------------------------------------------------------

class LisrResponse : public ::google::protobuf::Message {
 public:
  LisrResponse();
  virtual ~LisrResponse();

  LisrResponse(const LisrResponse& from);

  inline LisrResponse& operator=(const LisrResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LisrResponse& default_instance();

  void Swap(LisrResponse* other);

  // implements Message ----------------------------------------------

  inline LisrResponse* New() const { return New(NULL); }

  LisrResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LisrResponse& from);
  void MergeFrom(const LisrResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LisrResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:RCMMessage.LisrResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static LisrResponse* default_instance_;
};
// -------------------------------------------------------------------

class SearchRequest : public ::google::protobuf::Message {
 public:
  SearchRequest();
  virtual ~SearchRequest();

  SearchRequest(const SearchRequest& from);

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRequest& default_instance();

  void Swap(SearchRequest* other);

  // implements Message ----------------------------------------------

  inline SearchRequest* New() const { return New(NULL); }

  SearchRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:RCMMessage.SearchRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static SearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchResponse : public ::google::protobuf::Message {
 public:
  SearchResponse();
  virtual ~SearchResponse();

  SearchResponse(const SearchResponse& from);

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResponse& default_instance();

  void Swap(SearchResponse* other);

  // implements Message ----------------------------------------------

  inline SearchResponse* New() const { return New(NULL); }

  SearchResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:RCMMessage.SearchResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static SearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RCMMessage.UploadRequest upload_req = 1;
  bool has_upload_req() const;
  void clear_upload_req();
  static const int kUploadReqFieldNumber = 1;
  const ::RCMMessage::UploadRequest& upload_req() const;
  ::RCMMessage::UploadRequest* mutable_upload_req();
  ::RCMMessage::UploadRequest* release_upload_req();
  void set_allocated_upload_req(::RCMMessage::UploadRequest* upload_req);

  // optional .RCMMessage.DownloadRequest download_req = 2;
  bool has_download_req() const;
  void clear_download_req();
  static const int kDownloadReqFieldNumber = 2;
  const ::RCMMessage::DownloadRequest& download_req() const;
  ::RCMMessage::DownloadRequest* mutable_download_req();
  ::RCMMessage::DownloadRequest* release_download_req();
  void set_allocated_download_req(::RCMMessage::DownloadRequest* download_req);

  // optional .RCMMessage.ListRequest list_req = 3;
  bool has_list_req() const;
  void clear_list_req();
  static const int kListReqFieldNumber = 3;
  const ::RCMMessage::ListRequest& list_req() const;
  ::RCMMessage::ListRequest* mutable_list_req();
  ::RCMMessage::ListRequest* release_list_req();
  void set_allocated_list_req(::RCMMessage::ListRequest* list_req);

  // optional .RCMMessage.SearchRequest search_req = 4;
  bool has_search_req() const;
  void clear_search_req();
  static const int kSearchReqFieldNumber = 4;
  const ::RCMMessage::SearchRequest& search_req() const;
  ::RCMMessage::SearchRequest* mutable_search_req();
  ::RCMMessage::SearchRequest* release_search_req();
  void set_allocated_search_req(::RCMMessage::SearchRequest* search_req);

  // @@protoc_insertion_point(class_scope:RCMMessage.Request)
 private:
  inline void set_has_upload_req();
  inline void clear_has_upload_req();
  inline void set_has_download_req();
  inline void clear_has_download_req();
  inline void set_has_list_req();
  inline void clear_has_list_req();
  inline void set_has_search_req();
  inline void clear_has_search_req();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RCMMessage::UploadRequest* upload_req_;
  ::RCMMessage::DownloadRequest* download_req_;
  ::RCMMessage::ListRequest* list_req_;
  ::RCMMessage::SearchRequest* search_req_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // optional bytes error_description = 2;
  bool has_error_description() const;
  void clear_error_description();
  static const int kErrorDescriptionFieldNumber = 2;
  const ::std::string& error_description() const;
  void set_error_description(const ::std::string& value);
  void set_error_description(const char* value);
  void set_error_description(const void* value, size_t size);
  ::std::string* mutable_error_description();
  ::std::string* release_error_description();
  void set_allocated_error_description(::std::string* error_description);

  // required bool last_block = 3;
  bool has_last_block() const;
  void clear_last_block();
  static const int kLastBlockFieldNumber = 3;
  bool last_block() const;
  void set_last_block(bool value);

  // required fixed32 block_index = 4;
  bool has_block_index() const;
  void clear_block_index();
  static const int kBlockIndexFieldNumber = 4;
  ::google::protobuf::uint32 block_index() const;
  void set_block_index(::google::protobuf::uint32 value);

  // optional .RCMMessage.UploadResponse upload_res = 5;
  bool has_upload_res() const;
  void clear_upload_res();
  static const int kUploadResFieldNumber = 5;
  const ::RCMMessage::UploadResponse& upload_res() const;
  ::RCMMessage::UploadResponse* mutable_upload_res();
  ::RCMMessage::UploadResponse* release_upload_res();
  void set_allocated_upload_res(::RCMMessage::UploadResponse* upload_res);

  // optional .RCMMessage.DownladResponse download_res = 6;
  bool has_download_res() const;
  void clear_download_res();
  static const int kDownloadResFieldNumber = 6;
  const ::RCMMessage::DownladResponse& download_res() const;
  ::RCMMessage::DownladResponse* mutable_download_res();
  ::RCMMessage::DownladResponse* release_download_res();
  void set_allocated_download_res(::RCMMessage::DownladResponse* download_res);

  // optional .RCMMessage.LisrResponse list_res = 7;
  bool has_list_res() const;
  void clear_list_res();
  static const int kListResFieldNumber = 7;
  const ::RCMMessage::LisrResponse& list_res() const;
  ::RCMMessage::LisrResponse* mutable_list_res();
  ::RCMMessage::LisrResponse* release_list_res();
  void set_allocated_list_res(::RCMMessage::LisrResponse* list_res);

  // optional .RCMMessage.SearchResponse search_res = 8;
  bool has_search_res() const;
  void clear_search_res();
  static const int kSearchResFieldNumber = 8;
  const ::RCMMessage::SearchResponse& search_res() const;
  ::RCMMessage::SearchResponse* mutable_search_res();
  ::RCMMessage::SearchResponse* release_search_res();
  void set_allocated_search_res(::RCMMessage::SearchResponse* search_res);

  // @@protoc_insertion_point(class_scope:RCMMessage.Response)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_description();
  inline void clear_has_error_description();
  inline void set_has_last_block();
  inline void clear_has_last_block();
  inline void set_has_block_index();
  inline void clear_has_block_index();
  inline void set_has_upload_res();
  inline void clear_has_upload_res();
  inline void set_has_download_res();
  inline void clear_has_download_res();
  inline void set_has_list_res();
  inline void clear_has_list_res();
  inline void set_has_search_res();
  inline void clear_has_search_res();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_description_;
  bool result_;
  bool last_block_;
  ::google::protobuf::uint32 block_index_;
  ::RCMMessage::UploadResponse* upload_res_;
  ::RCMMessage::DownladResponse* download_res_;
  ::RCMMessage::LisrResponse* list_res_;
  ::RCMMessage::SearchResponse* search_res_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RCMMessage.MSG type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::RCMMessage::MSG type() const;
  void set_type(::RCMMessage::MSG value);

  // required fixed32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional .RCMMessage.Request request = 3;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 3;
  const ::RCMMessage::Request& request() const;
  ::RCMMessage::Request* mutable_request();
  ::RCMMessage::Request* release_request();
  void set_allocated_request(::RCMMessage::Request* request);

  // optional .RCMMessage.Response response = 4;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 4;
  const ::RCMMessage::Response& response() const;
  ::RCMMessage::Response* mutable_response();
  ::RCMMessage::Response* release_response();
  void set_allocated_response(::RCMMessage::Response* response);

  // @@protoc_insertion_point(class_scope:RCMMessage.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 sequence_;
  ::RCMMessage::Request* request_;
  ::RCMMessage::Response* response_;
  friend void  protobuf_AddDesc_RCMMessage_2eproto();
  friend void protobuf_AssignDesc_RCMMessage_2eproto();
  friend void protobuf_ShutdownFile_RCMMessage_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// UploadRequest

// required string fileName = 1;
inline bool UploadRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& UploadRequest::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.UploadRequest.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.UploadRequest.fileName)
}
inline void UploadRequest::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.UploadRequest.fileName)
}
inline void UploadRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.UploadRequest.fileName)
}
inline ::std::string* UploadRequest::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.UploadRequest.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadRequest::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.UploadRequest.fileName)
}

// required string IP = 2;
inline bool UploadRequest::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadRequest::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadRequest::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadRequest::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& UploadRequest::ip() const {
  // @@protoc_insertion_point(field_get:RCMMessage.UploadRequest.IP)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.UploadRequest.IP)
}
inline void UploadRequest::set_ip(const char* value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.UploadRequest.IP)
}
inline void UploadRequest::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.UploadRequest.IP)
}
inline ::std::string* UploadRequest::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:RCMMessage.UploadRequest.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadRequest::release_ip() {
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.UploadRequest.IP)
}

// required bool fileSet = 3;
inline bool UploadRequest::has_fileset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadRequest::set_has_fileset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadRequest::clear_has_fileset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadRequest::clear_fileset() {
  fileset_ = false;
  clear_has_fileset();
}
inline bool UploadRequest::fileset() const {
  // @@protoc_insertion_point(field_get:RCMMessage.UploadRequest.fileSet)
  return fileset_;
}
inline void UploadRequest::set_fileset(bool value) {
  set_has_fileset();
  fileset_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.UploadRequest.fileSet)
}

// required bool fileEnd = 4;
inline bool UploadRequest::has_fileend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UploadRequest::set_has_fileend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UploadRequest::clear_has_fileend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UploadRequest::clear_fileend() {
  fileend_ = false;
  clear_has_fileend();
}
inline bool UploadRequest::fileend() const {
  // @@protoc_insertion_point(field_get:RCMMessage.UploadRequest.fileEnd)
  return fileend_;
}
inline void UploadRequest::set_fileend(bool value) {
  set_has_fileend();
  fileend_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.UploadRequest.fileEnd)
}

// required bytes content = 5;
inline bool UploadRequest::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UploadRequest::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UploadRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UploadRequest::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& UploadRequest::content() const {
  // @@protoc_insertion_point(field_get:RCMMessage.UploadRequest.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.UploadRequest.content)
}
inline void UploadRequest::set_content(const char* value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.UploadRequest.content)
}
inline void UploadRequest::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.UploadRequest.content)
}
inline ::std::string* UploadRequest::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:RCMMessage.UploadRequest.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadRequest::release_content() {
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadRequest::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.UploadRequest.content)
}

// -------------------------------------------------------------------

// UploadResponse

// required string fileName = 1;
inline bool UploadResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadResponse::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& UploadResponse::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.UploadResponse.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.UploadResponse.fileName)
}
inline void UploadResponse::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.UploadResponse.fileName)
}
inline void UploadResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.UploadResponse.fileName)
}
inline ::std::string* UploadResponse::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.UploadResponse.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadResponse::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadResponse::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.UploadResponse.fileName)
}

// -------------------------------------------------------------------

// DownloadRequest

// required string fileName = 1;
inline bool DownloadRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& DownloadRequest::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.DownloadRequest.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.DownloadRequest.fileName)
}
inline void DownloadRequest::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.DownloadRequest.fileName)
}
inline void DownloadRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.DownloadRequest.fileName)
}
inline ::std::string* DownloadRequest::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.DownloadRequest.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DownloadRequest::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.DownloadRequest.fileName)
}

// -------------------------------------------------------------------

// DownladResponse

// required int32 isError = 1;
inline bool DownladResponse::has_iserror() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownladResponse::set_has_iserror() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownladResponse::clear_has_iserror() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownladResponse::clear_iserror() {
  iserror_ = 0;
  clear_has_iserror();
}
inline ::google::protobuf::int32 DownladResponse::iserror() const {
  // @@protoc_insertion_point(field_get:RCMMessage.DownladResponse.isError)
  return iserror_;
}
inline void DownladResponse::set_iserror(::google::protobuf::int32 value) {
  set_has_iserror();
  iserror_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.DownladResponse.isError)
}

// optional string errorInfo = 2;
inline bool DownladResponse::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownladResponse::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownladResponse::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownladResponse::clear_errorinfo() {
  errorinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errorinfo();
}
inline const ::std::string& DownladResponse::errorinfo() const {
  // @@protoc_insertion_point(field_get:RCMMessage.DownladResponse.errorInfo)
  return errorinfo_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownladResponse::set_errorinfo(const ::std::string& value) {
  set_has_errorinfo();
  errorinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.DownladResponse.errorInfo)
}
inline void DownladResponse::set_errorinfo(const char* value) {
  set_has_errorinfo();
  errorinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.DownladResponse.errorInfo)
}
inline void DownladResponse::set_errorinfo(const char* value, size_t size) {
  set_has_errorinfo();
  errorinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.DownladResponse.errorInfo)
}
inline ::std::string* DownladResponse::mutable_errorinfo() {
  set_has_errorinfo();
  // @@protoc_insertion_point(field_mutable:RCMMessage.DownladResponse.errorInfo)
  return errorinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DownladResponse::release_errorinfo() {
  clear_has_errorinfo();
  return errorinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownladResponse::set_allocated_errorinfo(::std::string* errorinfo) {
  if (errorinfo != NULL) {
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errorinfo);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.DownladResponse.errorInfo)
}

// -------------------------------------------------------------------

// ListRequest

// required string fileName = 1;
inline bool ListRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& ListRequest::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.ListRequest.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.ListRequest.fileName)
}
inline void ListRequest::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.ListRequest.fileName)
}
inline void ListRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.ListRequest.fileName)
}
inline ::std::string* ListRequest::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.ListRequest.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListRequest::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.ListRequest.fileName)
}

// -------------------------------------------------------------------

// LisrResponse

// required string fileName = 1;
inline bool LisrResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LisrResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LisrResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LisrResponse::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& LisrResponse::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.LisrResponse.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LisrResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.LisrResponse.fileName)
}
inline void LisrResponse::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.LisrResponse.fileName)
}
inline void LisrResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.LisrResponse.fileName)
}
inline ::std::string* LisrResponse::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.LisrResponse.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LisrResponse::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LisrResponse::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.LisrResponse.fileName)
}

// -------------------------------------------------------------------

// SearchRequest

// required string fileName = 1;
inline bool SearchRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& SearchRequest::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.SearchRequest.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.SearchRequest.fileName)
}
inline void SearchRequest::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.SearchRequest.fileName)
}
inline void SearchRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.SearchRequest.fileName)
}
inline ::std::string* SearchRequest::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.SearchRequest.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchRequest::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.SearchRequest.fileName)
}

// -------------------------------------------------------------------

// SearchResponse

// required string fileName = 1;
inline bool SearchResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchResponse::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& SearchResponse::filename() const {
  // @@protoc_insertion_point(field_get:RCMMessage.SearchResponse.fileName)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.SearchResponse.fileName)
}
inline void SearchResponse::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.SearchResponse.fileName)
}
inline void SearchResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.SearchResponse.fileName)
}
inline ::std::string* SearchResponse::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:RCMMessage.SearchResponse.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchResponse::release_filename() {
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchResponse::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.SearchResponse.fileName)
}

// -------------------------------------------------------------------

// Request

// optional .RCMMessage.UploadRequest upload_req = 1;
inline bool Request::has_upload_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_upload_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_upload_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_upload_req() {
  if (upload_req_ != NULL) upload_req_->::RCMMessage::UploadRequest::Clear();
  clear_has_upload_req();
}
inline const ::RCMMessage::UploadRequest& Request::upload_req() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Request.upload_req)
  return upload_req_ != NULL ? *upload_req_ : *default_instance_->upload_req_;
}
inline ::RCMMessage::UploadRequest* Request::mutable_upload_req() {
  set_has_upload_req();
  if (upload_req_ == NULL) {
    upload_req_ = new ::RCMMessage::UploadRequest;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Request.upload_req)
  return upload_req_;
}
inline ::RCMMessage::UploadRequest* Request::release_upload_req() {
  clear_has_upload_req();
  ::RCMMessage::UploadRequest* temp = upload_req_;
  upload_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_upload_req(::RCMMessage::UploadRequest* upload_req) {
  delete upload_req_;
  upload_req_ = upload_req;
  if (upload_req) {
    set_has_upload_req();
  } else {
    clear_has_upload_req();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Request.upload_req)
}

// optional .RCMMessage.DownloadRequest download_req = 2;
inline bool Request::has_download_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_download_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_download_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_download_req() {
  if (download_req_ != NULL) download_req_->::RCMMessage::DownloadRequest::Clear();
  clear_has_download_req();
}
inline const ::RCMMessage::DownloadRequest& Request::download_req() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Request.download_req)
  return download_req_ != NULL ? *download_req_ : *default_instance_->download_req_;
}
inline ::RCMMessage::DownloadRequest* Request::mutable_download_req() {
  set_has_download_req();
  if (download_req_ == NULL) {
    download_req_ = new ::RCMMessage::DownloadRequest;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Request.download_req)
  return download_req_;
}
inline ::RCMMessage::DownloadRequest* Request::release_download_req() {
  clear_has_download_req();
  ::RCMMessage::DownloadRequest* temp = download_req_;
  download_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_download_req(::RCMMessage::DownloadRequest* download_req) {
  delete download_req_;
  download_req_ = download_req;
  if (download_req) {
    set_has_download_req();
  } else {
    clear_has_download_req();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Request.download_req)
}

// optional .RCMMessage.ListRequest list_req = 3;
inline bool Request::has_list_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_list_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_list_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_list_req() {
  if (list_req_ != NULL) list_req_->::RCMMessage::ListRequest::Clear();
  clear_has_list_req();
}
inline const ::RCMMessage::ListRequest& Request::list_req() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Request.list_req)
  return list_req_ != NULL ? *list_req_ : *default_instance_->list_req_;
}
inline ::RCMMessage::ListRequest* Request::mutable_list_req() {
  set_has_list_req();
  if (list_req_ == NULL) {
    list_req_ = new ::RCMMessage::ListRequest;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Request.list_req)
  return list_req_;
}
inline ::RCMMessage::ListRequest* Request::release_list_req() {
  clear_has_list_req();
  ::RCMMessage::ListRequest* temp = list_req_;
  list_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_list_req(::RCMMessage::ListRequest* list_req) {
  delete list_req_;
  list_req_ = list_req;
  if (list_req) {
    set_has_list_req();
  } else {
    clear_has_list_req();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Request.list_req)
}

// optional .RCMMessage.SearchRequest search_req = 4;
inline bool Request::has_search_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_search_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_search_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_search_req() {
  if (search_req_ != NULL) search_req_->::RCMMessage::SearchRequest::Clear();
  clear_has_search_req();
}
inline const ::RCMMessage::SearchRequest& Request::search_req() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Request.search_req)
  return search_req_ != NULL ? *search_req_ : *default_instance_->search_req_;
}
inline ::RCMMessage::SearchRequest* Request::mutable_search_req() {
  set_has_search_req();
  if (search_req_ == NULL) {
    search_req_ = new ::RCMMessage::SearchRequest;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Request.search_req)
  return search_req_;
}
inline ::RCMMessage::SearchRequest* Request::release_search_req() {
  clear_has_search_req();
  ::RCMMessage::SearchRequest* temp = search_req_;
  search_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_search_req(::RCMMessage::SearchRequest* search_req) {
  delete search_req_;
  search_req_ = search_req;
  if (search_req) {
    set_has_search_req();
  } else {
    clear_has_search_req();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Request.search_req)
}

// -------------------------------------------------------------------

// Response

// required bool result = 1;
inline bool Response::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool Response::result() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.result)
  return result_;
}
inline void Response::set_result(bool value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.Response.result)
}

// optional bytes error_description = 2;
inline bool Response::has_error_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error_description() {
  error_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_description();
}
inline const ::std::string& Response::error_description() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.error_description)
  return error_description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_error_description(const ::std::string& value) {
  set_has_error_description();
  error_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RCMMessage.Response.error_description)
}
inline void Response::set_error_description(const char* value) {
  set_has_error_description();
  error_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RCMMessage.Response.error_description)
}
inline void Response::set_error_description(const void* value, size_t size) {
  set_has_error_description();
  error_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RCMMessage.Response.error_description)
}
inline ::std::string* Response::mutable_error_description() {
  set_has_error_description();
  // @@protoc_insertion_point(field_mutable:RCMMessage.Response.error_description)
  return error_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_error_description() {
  clear_has_error_description();
  return error_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_error_description(::std::string* error_description) {
  if (error_description != NULL) {
    set_has_error_description();
  } else {
    clear_has_error_description();
  }
  error_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_description);
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Response.error_description)
}

// required bool last_block = 3;
inline bool Response::has_last_block() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_last_block() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_last_block() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_last_block() {
  last_block_ = false;
  clear_has_last_block();
}
inline bool Response::last_block() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.last_block)
  return last_block_;
}
inline void Response::set_last_block(bool value) {
  set_has_last_block();
  last_block_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.Response.last_block)
}

// required fixed32 block_index = 4;
inline bool Response::has_block_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_block_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_block_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_block_index() {
  block_index_ = 0u;
  clear_has_block_index();
}
inline ::google::protobuf::uint32 Response::block_index() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.block_index)
  return block_index_;
}
inline void Response::set_block_index(::google::protobuf::uint32 value) {
  set_has_block_index();
  block_index_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.Response.block_index)
}

// optional .RCMMessage.UploadResponse upload_res = 5;
inline bool Response::has_upload_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_upload_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_upload_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_upload_res() {
  if (upload_res_ != NULL) upload_res_->::RCMMessage::UploadResponse::Clear();
  clear_has_upload_res();
}
inline const ::RCMMessage::UploadResponse& Response::upload_res() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.upload_res)
  return upload_res_ != NULL ? *upload_res_ : *default_instance_->upload_res_;
}
inline ::RCMMessage::UploadResponse* Response::mutable_upload_res() {
  set_has_upload_res();
  if (upload_res_ == NULL) {
    upload_res_ = new ::RCMMessage::UploadResponse;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Response.upload_res)
  return upload_res_;
}
inline ::RCMMessage::UploadResponse* Response::release_upload_res() {
  clear_has_upload_res();
  ::RCMMessage::UploadResponse* temp = upload_res_;
  upload_res_ = NULL;
  return temp;
}
inline void Response::set_allocated_upload_res(::RCMMessage::UploadResponse* upload_res) {
  delete upload_res_;
  upload_res_ = upload_res;
  if (upload_res) {
    set_has_upload_res();
  } else {
    clear_has_upload_res();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Response.upload_res)
}

// optional .RCMMessage.DownladResponse download_res = 6;
inline bool Response::has_download_res() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_download_res() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_download_res() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_download_res() {
  if (download_res_ != NULL) download_res_->::RCMMessage::DownladResponse::Clear();
  clear_has_download_res();
}
inline const ::RCMMessage::DownladResponse& Response::download_res() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.download_res)
  return download_res_ != NULL ? *download_res_ : *default_instance_->download_res_;
}
inline ::RCMMessage::DownladResponse* Response::mutable_download_res() {
  set_has_download_res();
  if (download_res_ == NULL) {
    download_res_ = new ::RCMMessage::DownladResponse;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Response.download_res)
  return download_res_;
}
inline ::RCMMessage::DownladResponse* Response::release_download_res() {
  clear_has_download_res();
  ::RCMMessage::DownladResponse* temp = download_res_;
  download_res_ = NULL;
  return temp;
}
inline void Response::set_allocated_download_res(::RCMMessage::DownladResponse* download_res) {
  delete download_res_;
  download_res_ = download_res;
  if (download_res) {
    set_has_download_res();
  } else {
    clear_has_download_res();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Response.download_res)
}

// optional .RCMMessage.LisrResponse list_res = 7;
inline bool Response::has_list_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_list_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_list_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_list_res() {
  if (list_res_ != NULL) list_res_->::RCMMessage::LisrResponse::Clear();
  clear_has_list_res();
}
inline const ::RCMMessage::LisrResponse& Response::list_res() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.list_res)
  return list_res_ != NULL ? *list_res_ : *default_instance_->list_res_;
}
inline ::RCMMessage::LisrResponse* Response::mutable_list_res() {
  set_has_list_res();
  if (list_res_ == NULL) {
    list_res_ = new ::RCMMessage::LisrResponse;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Response.list_res)
  return list_res_;
}
inline ::RCMMessage::LisrResponse* Response::release_list_res() {
  clear_has_list_res();
  ::RCMMessage::LisrResponse* temp = list_res_;
  list_res_ = NULL;
  return temp;
}
inline void Response::set_allocated_list_res(::RCMMessage::LisrResponse* list_res) {
  delete list_res_;
  list_res_ = list_res;
  if (list_res) {
    set_has_list_res();
  } else {
    clear_has_list_res();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Response.list_res)
}

// optional .RCMMessage.SearchResponse search_res = 8;
inline bool Response::has_search_res() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_search_res() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_search_res() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_search_res() {
  if (search_res_ != NULL) search_res_->::RCMMessage::SearchResponse::Clear();
  clear_has_search_res();
}
inline const ::RCMMessage::SearchResponse& Response::search_res() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Response.search_res)
  return search_res_ != NULL ? *search_res_ : *default_instance_->search_res_;
}
inline ::RCMMessage::SearchResponse* Response::mutable_search_res() {
  set_has_search_res();
  if (search_res_ == NULL) {
    search_res_ = new ::RCMMessage::SearchResponse;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Response.search_res)
  return search_res_;
}
inline ::RCMMessage::SearchResponse* Response::release_search_res() {
  clear_has_search_res();
  ::RCMMessage::SearchResponse* temp = search_res_;
  search_res_ = NULL;
  return temp;
}
inline void Response::set_allocated_search_res(::RCMMessage::SearchResponse* search_res) {
  delete search_res_;
  search_res_ = search_res;
  if (search_res) {
    set_has_search_res();
  } else {
    clear_has_search_res();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Response.search_res)
}

// -------------------------------------------------------------------

// Message

// required .RCMMessage.MSG type = 1;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 4097;
  clear_has_type();
}
inline ::RCMMessage::MSG Message::type() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Message.type)
  return static_cast< ::RCMMessage::MSG >(type_);
}
inline void Message::set_type(::RCMMessage::MSG value) {
  assert(::RCMMessage::MSG_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.Message.type)
}

// required fixed32 sequence = 2;
inline bool Message::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Message::sequence() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Message.sequence)
  return sequence_;
}
inline void Message::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:RCMMessage.Message.sequence)
}

// optional .RCMMessage.Request request = 3;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_request() {
  if (request_ != NULL) request_->::RCMMessage::Request::Clear();
  clear_has_request();
}
inline const ::RCMMessage::Request& Message::request() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Message.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::RCMMessage::Request* Message::mutable_request() {
  set_has_request();
  if (request_ == NULL) {
    request_ = new ::RCMMessage::Request;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Message.request)
  return request_;
}
inline ::RCMMessage::Request* Message::release_request() {
  clear_has_request();
  ::RCMMessage::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Message::set_allocated_request(::RCMMessage::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Message.request)
}

// optional .RCMMessage.Response response = 4;
inline bool Message::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_response() {
  if (response_ != NULL) response_->::RCMMessage::Response::Clear();
  clear_has_response();
}
inline const ::RCMMessage::Response& Message::response() const {
  // @@protoc_insertion_point(field_get:RCMMessage.Message.response)
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::RCMMessage::Response* Message::mutable_response() {
  set_has_response();
  if (response_ == NULL) {
    response_ = new ::RCMMessage::Response;
  }
  // @@protoc_insertion_point(field_mutable:RCMMessage.Message.response)
  return response_;
}
inline ::RCMMessage::Response* Message::release_response() {
  clear_has_response();
  ::RCMMessage::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Message::set_allocated_response(::RCMMessage::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
  // @@protoc_insertion_point(field_set_allocated:RCMMessage.Message.response)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace RCMMessage

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RCMMessage::MSG> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RCMMessage::MSG>() {
  return ::RCMMessage::MSG_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RCMMessage_2eproto__INCLUDED
